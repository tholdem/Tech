global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'
endglobal	

context "math()"
snippet ww "omega" iA
\omega
endsnippet

context "math()"
snippet WW "Omega" iA
\Omega
endsnippet

context "math()"
snippet oc "circ" A
\circ 
endsnippet

context "math()"
snippet stab "stablizer" A
\Stab_{ $1}( $2) $0
endsnippet

context "math()"
snippet supr "supremum" iA
\sup\left\\{$1 \right\\} $0
endsnippet

context "math()"
snippet infim "infimum" iA
\inf\left\\{$1 \right\\} $0
endsnippet

context "math()"
snippet 1nor "1 norm (custom command)" iA
\norm{ $1}_1 $0
endsnippet

context "math()"
snippet 2nor "2 norm (custom command)" iA
\norm{ $1}_2 $0
endsnippet

context "math()"
snippet infnor "infinity norm (custom command)" iA
\norm{ $1}_{\infty} $0
endsnippet

context "math()"
snippet lam "lambda" iA
\lambda
endsnippet

context "math()"
snippet cv "conv" iA
\conv
endsnippet

context "math()"
snippet ep "epi" iA
\epi
endsnippet

context "math()"
snippet af "aff" iA
\aff
endsnippet

context "math()"
snippet Be "epsilon ball" iA
B_{ ${1:\epsilon}} ( $0 )
endsnippet

context "math()"
snippet inte "interior" iA
\inte 
endsnippet

context "math()"
snippet dom "domain" iA
\dom
endsnippet

context "math()"
snippet suc "succ" iA
\succ
endsnippet

context "math()"
snippet pre "prec" iA
\prec
endsnippet

snippet optprob "optimization problem standard form" bA
\begin{align*}
\min\quad &f_0(x) \\\
\text{subject to } \quad &f_i(x) \leq 0, i = 1,\ldots,m \\\
&h_i(x) = 0 , i = 1,\ldots,p
\end{align*}
endsnippet

context "math()"
snippet LL "Lagrangian" wA
\mathscr{L}
endsnippet

context "math()"
snippet LT "Laplace transform" wA
\mathcal{L}\left\\{ ${1}\right\\} $0
endsnippet

context "math()"
snippet iL "inverse Laplace transform" wA
\mathcal{L}^{-1}\left\\{ ${1}\right\\} $0
endsnippet

context "math()"
snippet '([A-Za-z])\.' "time derivative" wrA
\dot{`!p snip.rv = match.group(1)`}
endsnippet

context "math()"
snippet sup "supremum" wA
\sup 
endsnippet

context "math()"
snippet inf "infimum" wA
\inf
endsnippet

context "math()"
snippet bsc "big square cup" iA
\bigsqcup_{ $1}
endsnippet

context "math()"
snippet xra "words on right arrow" iA
\xrightarrow{ $1} $0
endsnippet

context "math()"
snippet im "image" A
\im $0
endsnippet

context "math()"
snippet dg "degree" A
\dg $0
endsnippet

context "math()"
snippet mod "modulo" iA
\bmod $0
endsnippet

context "math()"
snippet ker "kernel" A
\ker $0
endsnippet

context "math()"
snippet iso "isomorphic" iA
\cong
endsnippet

context "math()"
snippet sim "equivalence" iA
\sim
endsnippet

context "math()"
snippet io "iota" A
\iota 
endsnippet

context "math()"
snippet pp "subscript p" iA
_p
endsnippet

context "math()"
snippet mm "subscript m" iA
_m
endsnippet

context "math()"
snippet -= "homotopic" iA
\simeq 
endsnippet

context "math()"
snippet id "identity" A
\text{id}_{ $1}
endsnippet

context "math()"
snippet SS "Sigma" A
\Sigma 
endsnippet

context "math()"
snippet int "interior" A
\inte 
endsnippet

context "math()"
snippet oc "circ" A
\circ 
endsnippet

context "math()"
snippet inje "injection" A
\rightarrowtail
endsnippet

context "math()"
snippet surj "surjection" A
\twoheadrightarrow
endsnippet

context "math()"
snippet bico "bijection correspondence" A
\leftrightarrow
endsnippet

snippet nbhd "neighborhood" A
neighborhood 
endsnippet

context "math()"
snippet rot "Rot" A
\Rot
endsnippet

context "math()"
snippet ata "atan2" A
\atan2 
endsnippet

# vim:ft=snippets

